{"pages":[{"title":"about","text":"","link":"/about/index-1.html"},{"title":"about","text":"","link":"/about/index-2.html"},{"title":"Minos - A Hexo theme","text":"","link":"/about/index.html"}],"posts":[{"title":"About Hoisting, Closure and Prototype","text":"Hoisting 變數提升 example_1 ( 變數 ) 12console.log(a)var a = 1 可以看成 2 步驟拆解： first : 將變數拆解 123console.log(a)var aa = 1 second : 再提升變數 因此在程式跑到 console.log(a) 之前就可以先使用此變數。 123var a console.log(a)a = 1 example_2 (function) 正常做法 : 12345function test() &#123; console.log(123)&#125;test() 因 hoisting 關係，因此以下程式碼也可運行。 12345test()function test() &#123; console.log(123)&#125; Closure 閉包 example_1 12345678function test() &#123; var a = 10 console.log(a)&#125;// 是否能在 function 外存取變數 a ?console.log(a)test() answer : 因作用域的不同，在 function 之外無法存取變數 a，且執行完 function 後，裡面的變數會被同時釋放掉。 example_2 12345678var count = 0function addCount() &#123; count++ return count&#125;console.log(addCount()) // 1console.log(addCount()) // 2 question : 變數可被改變，連帶影響輸出的值，因此應該要以別的方式避免變數被更改。 123456789var count = 0function addCount() &#123; count++ return count&#125;console.log(addCount()) // 1count = 10console.log(addCount()) // 11 solution : 再產生一個新的作用域，將變數放置在此，使外部存取不到此變數。( 可簡單想成 -&gt; 在 function 裡 return 一個 function)。 123456789101112function createCounter() &#123; var count = 0 function addCount() &#123; count++ return count &#125; return addCount&#125;var counter = createCounter()console.log(counter())console.log(counter()) or 1234567891011function createCounter() &#123; var count = 0 return function () &#123; count++ return count &#125;&#125;var counter = createCounter()console.log(counter())console.log(counter()) Prototype example_1 : JavaScript 中物件導向的用法 1234567function Person(name) &#123; this.name = name&#125;var nick = new Person(&apos;nick&apos;)var peter = new Person(&apos;peter&apos;)console.log(nick.name, peter.name) example_2 : 123456789101112function Person(name) &#123; this.name = name this.getName = function () &#123; return this.name &#125;&#125;var nick = new Person(&apos;nick&apos;)var peter = new Person(&apos;peter&apos;)console.log(nick.getName())console.log(nick.getName === peter.getName) // false// 記憶體指向不同地方 example_3 : 1234567891011function Person(name) &#123; this.name = name&#125;Person.prototype.getName = function () &#123; return this.name&#125;var nick = new Person(&apos;nick&apos;)var peter = new Person(&apos;peter&apos;)console.log(nick.getName === peter.getName) // true","link":"/2019/10/09/About Hoisting, Closure and Prototype/"},{"title":"About `window.setTimeout()`","text":"在先前的 Event Loop + Scope 實作中，發現一項有趣的返回值 123456for(var i=0; i&lt;5; i++) &#123; console.log(&apos;i: &apos; + i) setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000)&#125; 此時使用 node.js 中會得到的答案為： 12345678910i: 0i: 1i: 2i: 3i: 45 (第 0 秒)5 (第 1 秒) 5 (第 2 秒) 5 (第 3 秒) 5 (第 4 秒) 但如果使用瀏覽器中的 devTools 則會出現此項現象： 1234567891011i: 0i: 1i: 2i: 3i: 4此行會多出一個數值5 (第 0 秒)5 (第 1 秒) 5 (第 2 秒) 5 (第 3 秒) 5 (第 4 秒) 可能會依據所使用的不同瀏覽器 (Chorme, Mozilla Firefox) 而回傳一個不同的數值，甚至是使用一般分頁或是無痕模式分頁也會有所不同。 setTimeout() The setTimeout() sets a timer which executes a function or specified piece of code once the timer expires. 根據 MDN 定義 setTimeout() 的作用，會在延遲某段時間後，執行之中的程式碼 Return value : timeoutID 返回值 timeoutID 會是一個正整數，來表示 timer 的編號。之後這項值可以傳遞給 clearTimeout() 來取消 timer 使用。 因此當我們使用這段程式碼在不同瀏覽器或是不同狀態下的分頁的 devTools 進行測試時： 1setTimeout(() =&gt; &#123;&#125;, 0) 可以得到不同的數值，原因是這和瀏覽器背後處理過幾次 setTimeout() 有關。 Example We can set a timeout after few seconds and store the timeoutID for use by clearTimeout(). 123456789var timeoutIDfunction delayedAlert() &#123; timeoutID = window.setTimeout(window.alert, 2 * 1000, &apos;yo!&apos;)&#125;function clearAlert() &#123; window.clearTimeout(timeoutID)&#125; Reference WindowOrWorkerGlobalScope.setTimeout() WindowOrWorkerGlobalScope.clearTimeout()","link":"/2019/10/11/About `window.setTimeout()`/"},{"title":"let and const (ES6)","text":"const 全名為 constant ( 常數 )，相對於 var ( 變數 )，需要一開始即指定一初始值給 const，且不能在後續的步驟修改 const 的值。 需先指定一初始值，否則會出現錯誤 Missing initializer in const declaration 12const bb = 20 // Error: `Missing initializer in const declaration` 不能在後續修改 const 的值，否則出現錯誤 Assignment to constant variable 。 12const b = 10b = 20 // Error: `Assignment to constant variable` let 以及 var 則無此限制 應用 example 01 : 12345const obj = &#123; number: 1&#125;obj.number = 2 此時當執行 obj.number 時，程式會去修改其中 obj 所儲存的記憶體位置中的 number 的值，而不會去修改到記憶體位置，因此不會出錯，可想像成 12345678910110x01: &#123; number: 2&#125; // 其中的 number 的值修改成 2obj:0x01const obj = &#123; number: 1&#125;obj.number = 2 example 02 : 1234567const obj = &#123; number: 1&#125;obj = &#123; number: 2&#125; 這時已產生一個新的記憶體位置來放 number: 2 的值，之後再將這新的記憶體位置只給 obj 但此時已修改到 const obj 的值了，因此會發生錯誤。 12345678910111213141516170x01: &#123; number: 2&#125;0x02: &#123; number: 2&#125;obj:0x02 // obj 的值 ( 也就是儲存的記憶體位置 ) 被修改了const obj = &#123; number: 1&#125;obj = &#123; number: 2&#125; // Error: `Assignment to constant variable`","link":"/2019/09/21/Introduction - let and const (ES6)/"},{"title":"why do we need Gulp ?","text":"Automate and enhance your workflow 目的加強工作流程並自動化。 Gulp 為一個開源的 Task runner ( 工作執行器 )，建構在 node.js 和 npm 上，自動化整合套件。 提供的 API : gulp.task : 執行工作 gulp.src : 執行資料來源 gulp.dest : 執行結果位置 gulp.watch : 監視執行過程中資料是否變更 官方 gulpfile.js 12345678910111213141516171819202122232425262728293031// 引用 gulp pluginconst &#123; src, dest, parallel &#125; = require(&apos;gulp&apos;); const pug = require(&apos;gulp-pug&apos;);const less = require(&apos;gulp-less&apos;);const minifyCSS = require(&apos;gulp-csso&apos;);const concat = require(&apos;gulp-concat&apos;);// 建立 gulp taskfunction html() &#123;return src(&apos;client/templates/*.pug&apos;) .pipe(pug()) .pipe(dest(&apos;build/html&apos;))&#125;function css() &#123;return src(&apos;client/templates/*.less&apos;) .pipe(less()) .pipe(minifyCSS()) .pipe(dest(&apos;build/css&apos;))&#125;function js() &#123;return src(&apos;client/javascript/*.js&apos;, &#123; sourcemaps: true &#125;) .pipe(concat(&apos;app.min.js&apos;)) .pipe(dest(&apos;build/js&apos;, &#123; sourcemaps: true &#125;))&#125;exports.js = js;exports.css = css;exports.html = html;exports.default = parallel(html, css, js); 安裝 Gulp 流程 Check for node, npm, and npx 123node --versionnpm --versionnpx --version Install the gulp command line utility 1234npm install gulp-cli -g // 在 global 環境下安裝 gulpnpm install gulp -Dnpx -p touch nodetouch gulpfile.js // 設定檔放置在 gulpfile.jsgulp --help 安裝 gulp 相關套件 ( 以下列舉常見選項 ) gulp-sass gulp-uglify gulp-compass gulp-babel gulp-less gulp-rename gulp-clean-css del Create a project 12npx mkdirp my-projectcd my-project Create a package.json file in your project directory 1npm init Create a file named gulpfile.js in your project root with these contents : 123456function defaultTask(cb) &#123;// place code for your default task herecb();&#125;exports.default = defaultTask 當我們安裝 gulp 相關套件時，Usage 的地方都有提供詳細的引入方式。 start Gulp ~ 1gulp || gulp &lt;task&gt; &lt;othertask&gt; 實作 Gulp 範例 設定 gulpfile.js 檔 12345678910111213141516171819202122232425262728293031323334353637383940const gulp = require(&apos;gulp&apos;); // 載入 gulpconst sass = require(&apos;gulp-sass&apos;); // compile your Sass filesconst babel = require(&apos;gulp-babel&apos;); // 將 ES6 以上語法轉換成最基本 JS 語法const uglify = require(&apos;gulp-uglify&apos;); // minify JavaScriptconst rename = require(&apos;gulp-rename&apos;); // rename filesconst cleanCSS = require(&apos;gulp-clean-css&apos;); // minify CSSconst del = require(&apos;del&apos;); // Delete files and directories using globsfunction clean() &#123; return del(&apos;./build/*&apos;);&#125;function styles() &#123; return gulp.src(&apos;./src/css/app.scss&apos;) // 輸入路徑 .pipe(sass()) .pipe(cleanCSS()) .pipe(rename(&#123; basename: &apos;main&apos;, suffix: &apos;.min&apos; &#125;)) .pipe(gulp.dest(&apos;./build/css&apos;)); // 輸出路徑&#125;function scripts() &#123; return gulp.src(&apos;./src/js/*.js&apos;) .pipe(babel()) .pipe(uglify()) .pipe(gulp.dest(&apos;./build/js&apos;));&#125;function watch() &#123; gulp.watch(&apos;./css/style.scss&apos;, styles); gulp.watch(&apos;./js/*.js&apos;, scripts);&#125;exports.clean = clean;exports.styles = styles;exports.scripts = scripts;exports.watch = watch;exports.default = gulp.series(clean, styles, scripts); // 定義名稱為 default 的 gulp task watch 例如，當我們使用 gulp-uglify 用來 minify JavaScript 時，會希望每次 JavaScript 有異動時， gulp-uglify 可以監看並自動執行最小化。 1234function watch() &#123; gulp.watch(&apos;./css/style.scss&apos;, styles); gulp.watch(&apos;./js/*.js&apos;, scripts);&#125; 因此上述程式碼可以協助我們監看 css 以及 js 檔是否有異動來自動執行 function styles() and function scripts() 。 Reference Gulp 官網 Gulp 安裝與介紹 gulp gulp 學習筆記 gulp 入門指南","link":"/2019/09/28/Gulp - automate and enhance your workflow/"},{"title":"JavaScript 變數的資料型態","text":"primitive type ( 原始型態 ) null undefined string number boolean symbol (ES6) others object(array, function, date…) primitive type 與 object 資料型態的差別 其中最大差別在於 primitive type 為 Immutable 1234567var str = &apos;hello&apos;var newStr = str.toUpperCase()console.log(str, newStr) // hello HELLOvar arr = [1]arr.push(2)console.log(arr) // [1, 2] typeof 可使用 typeof 了解目前的資料型態 1234567891011console.log(typeof 42);// expected output: &quot;number&quot;console.log(typeof &apos;blubber&apos;);// expected output: &quot;string&quot;console.log(typeof true);// expected output: &quot;boolean&quot;console.log(typeof declaredButUndefinedVariable);// expected output: &quot;undefined&quot;; answer 1234&quot;number&quot;&quot;string&quot;&quot;boolean&quot;&quot;undefined&quot; Additional information null In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was 0. null was represented as the NULL pointer (0x00 in most platforms). Consequently, null had 0 as type tag, hence the “object” typeof return value. 12// This stands since the beginning of JavaScripttypeof null === &apos;object&apos;; Description The following table summarizes the possible return values of typeof Type Result Undefined “undefined” Null “object” (see below) Boolean “boolean” Number “number” BigInt “bigint” String “string” Symbol (new in ECMAScript 2015) “symbol” Host object (provided by the JS environment) Implementation-dependent Function object (implements [[Call]] in ECMA-262 terms) “function” Any other object “object” 但因為使用 typeof 在某些情況下可能不是很準確，例如無法檢測出是否為 array，因此可使用另外兩種方式 Array.isArray() The Array.isArray() method determines whether the passed value is an Array. 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false prototype 12345console.log(Object.prototype.toString.call(&apos;123&apos;))console.log(Object.prototype.toString.call(456))console.log(Object.prototype.toString.call([]))console.log(Object.prototype.toString.call(new Date()))console.log(Object.prototype.toString.call(null)) answer 12345[object String][object Number][object Array][object Date][object Null] Reference typeof Array.isArray()","link":"/2019/09/20/JavaScript 變數的資料型態/"},{"title":"Scope 作用域 (ES6 以前)","text":"變數的生存範圍 Scope 的最基本單位 - function 在 JavaScript 中，ES6 之前 Scope 的基本單位為 function，在 function 才能產生一個新的作用域。 1234567function test() &#123; var a = 10 console.log(a)&#125;test() // 10console.log(a) // ReferenceError: a is not defined 因此這個例子中，function test() 會產生一個 test scope，而 a 就會宣告在這個 test 的 scope 裡面，所以 a 只有在此 function 裡面才能被看到，在 function 之外就無法看到此變數，出現錯誤 ReferenceError: a is not defined 。 global variable 1234567var a = 20 // global variablefunction test() &#123; console.log(a)&#125;test() // 20console.log(a) // 20 優先順序 程式會優先尋找 function 中的變數，若無再往上至 global variable 尋找。 12345678var a = 20 // global variablefunction test() &#123; var a = 10 console.log(a)&#125;test() // 10console.log(a) // 20 若我們將變數範圍印出，可更清楚 scope 範圍 1234567891011121314var a = &apos;global&apos;function test() &#123; var a = &apos;test scope a&apos; var b = &apos;test scope b&apos; console.log(a, b) // test scope a, test scope b function inner() &#123; var b = &apos;inner scope b&apos; console.log(a, b) // test scope a, inner scope b &#125; inner() &#125;test() console.log(a) // global scope chain 作用域鍊 由上可得結論，作用域的優先尋找順序為 inner scope -&gt; test scope -&gt; global scope 。","link":"/2019/09/07/Scope - var (ES6 以前)/"},{"title":"Webpack 超入門安裝","text":"Global Installation 1npm install webpack --save-dev 建立專案資料夾 mkdir &lt;folder name&gt; cd &lt;folder name&gt; 建立 npm 專案 npm init package name : 專案名稱 version : 版本號 description : 專案敘述 entry point : 專案執行進入點 ( 預設值為 index.js) test ccommand : 專案測試指令 git repository : 專案原始碼的版本控管位置 keywords : 專案關鍵字 author : 專案作者 license : 專案版權 建置文件 src/index.js 123import bar from &apos;./bar&apos;;bar(); src/bar.js 123export default function bar() &#123; //&#125; 設定 webpack.config.js 檔 123456789const path = require(&apos;path&apos;); // 引用 path 模組module.exports = &#123; entry: &apos;./src/index.js&apos;, // webpack 打包對象 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125;; 在 html / or 文件中引入 12345678910&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 執行 1npx webpack --config webpack.config.js Reference webpack Installation 使用 Webpack 綁定應用程式 webpack 模組綁定程式","link":"/2019/10/05/Webpack/"},{"title":"let and const (ES6) 的生存範圍","text":"前言： 在 ES6 之前，scope 作用域的最基本單位為 function，只要有 function 就會產生新的作用域；但若在 ES6 之後，最基本單位為 block 。 scope var 作用域範圍為 function 之內都可使用 123456789function() &#123; var a = 60 if (a === 60) &#123; var b = 10 &#125; console.log(b) // 10&#125;test() let or const example 01 : 123456789function() &#123; var a = 60 if (a === 60) &#123; let b = 10 &#125; console.log(b) // b is not defined&#125;test() 因為在 ES6 之後，使用 let or const ，其作用域會存在於 block 中，因此在這個狀況下跳脫出 if 的範圍外後，就無法存取到 b 。 example 02 : 使用 var 宣告的情況下： 12345678function test() &#123; for (var i=0; i&lt;10; i++) &#123; console.log(&apos;i:&apos;, i) &#125; console.log(&apos;final value:&apos;, i)&#125;test() answer: 12345678910i: 1i: 2i: 3i: 4i: 5i: 6i: 7i: 8i: 9final value: 10 // 可存取到 function 中的所有變數 使用 let or const 宣告的情況下： 12345678function test() &#123; for (let i=0; i&lt;10; i++) &#123; console.log(&apos;i:&apos;, i) &#125; console.log(&apos;final value:&apos;, i)&#125;test() answer: 12345678910i: 1i: 2i: 3i: 4i: 5i: 6i: 7i: 8i: 9i is not defined","link":"/2019/09/08/Scope - let and const (ES6)/"},{"title":"What's `THIS` in JavaScript?","text":"前言 常常出現以及使用的 this 似乎是一個常見又難纏的敵人，以下整理及提供一些資料參考。 由物件導向的角度開始探討 試宣告了一個 class Car ，我們可以使用兩個 methods ( setName and getName )，並在裡面使用 this.name 存取 instance 的屬性，由此可見這裡的 this 指的對象就是 instance 本身 ( myCar )。 12345678910111213class Car &#123; setName(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125;&#125; const myCar = new Car()myCar.setName(&apos;hello&apos;)console.log(myCar.getName()) // hello 物件導向之外情況 嚴格模式下 =&gt; undefined 非嚴格模式，且在瀏覽器下執行 =&gt; window 非嚴格模式，且在 node.js 下執行 =&gt; global 更改 this 值 儘管 this 可能有預設值，但仍可透過一些方法去修改： 12345678&apos;use strict&apos;;function hello(a, b)&#123; console.log(this, a, b)&#125; hello(1, 2) // undefined 1 2hello.call(undefined, 1, 2) // undefined 1 2hello.apply(undefined, [1, 2]) // undefined 1 2 直接呼叫 function 上述程式碼可以從 function hello 可以 log 出 this 的值和 a, b 兩個參數，因此在呼叫 hello(1, 2) 的時候，在嚴格模式下 this 會是 undefined ， 而 a, b 分別為 1, 2。 使用 call 和 apply 方式呼叫 function。 當使用 hello.call(undefined, 1, 2) 的時候，會發現回傳結果和呼叫 hello(1, 2) 相同。 若使用 hello.apply(undefined, [1, 2]) 回傳值也是相同，差別部分在於傳進去的參數需要是 array 。 回到上述未解的問題，也就是一直為 undefined 的那項參數 =&gt; this 的值，以下舉例說明： example 01 : 1234567&apos;use strict&apos;;function hello(a, b)&#123; console.log(this, a, b)&#125;hello.call(&apos;yo&apos;, 1, 2) // yo 1 2hello.apply(&apos;hihihi&apos;, [1, 2]) // hihihi 1 2 有趣的是，傳進的的參數為何，this 的值就會是那項參數，覆蓋過預設的 this 值。 example 02 : 123456789class Car &#123; hello() &#123; console.log(this) &#125;&#125;const myCar = new Car()myCar.hello() // myCar instancemyCar.hello.call(&apos;yoyoyo&apos;) // yoyoyo 從上述程式碼可以得知，原本預設的 this 值為當我們呼叫 myCar.hello() 時回傳的 myCar 這項 instance，不過當我們使用 call 呼叫 function 時 ( myCar.hello.call('yoyoyo') // yoyoyo ) 所傳入的參數所覆蓋掉。 使用 bind 方式呼叫 function： bind 會回傳一個新的 function ，因此我們將 function hello 使用 my 綁定，最後呼叫 myHello() 時會輸出 my 。 1234567&apos;use strict&apos;;function hello() &#123; console.log(this)&#125;const myHello = hello.bind(&apos;my&apos;)myHello() // my 混用 call / apply and bind： 這邊可以發現，如果已經使用了 bind 之後 this 的值就不會再被改變了。 1234567&apos;use strict&apos;;function hello() &#123; console.log(this)&#125;const myHello = hello.bind(&apos;my&apos;)myHello.call(&apos;your&apos;) // my 物件中的 this 除了物件導向 class 中的 this ，接續探討一般 JavaScript 中的 object 的情況。 首先先宣告一項物件： 12345678const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;&#125;obj.hello() // 1 這邊所強調的重點為： this 的值與作用域或程式碼順序 / 位置無關，而是和如何呼叫有關。 this 的值會根據使用者如何呼叫 function 而不同，就如同上述所提的三種方式： call, apply and bind ，因此也就可以使用不同的方式呼叫 function 使 this 值有所不同。 Step 1 : 12345678910const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;&#125;obj.hello() // 1const hey = obj.hellohey() // undefined 可將上面這段程式碼的 function call 轉成使用 call 的形式來看： 123456789101112const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;&#125;obj.hello() // 1obj.hello.call(obj) // 轉成 callconst hey = obj.hellohey() // undefinedhey.call() // 轉成 call 此時 obj.hello() 變成 obj.hello.call(obj) ，而 hey() 前面沒有東西呼叫，因此變成 hey.call()。 Step 2 : 123456789101112131415161718const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;, inner: &#123; value: 2, hello: function() &#123; console.log(this.value) &#125; &#125;&#125;const obj2 = obj.innerconst hello = obj.inner.helloobj.inner.hello()obj2.hello()hello() 可把最後面這段想成 123obj.inner.hello() // obj.inner.hello.call(obj.inner) =&gt; 2obj2.hello() // obj2.hello.call(obj2) =&gt; 2hello() // hello.call() =&gt; undefined ( 非嚴格模式下 -&gt; window.value =&gt; undefined) question 01 : 1234567891011121314151617function hello() &#123; console.log(this)&#125;var a = &#123; value: 1, hello&#125;var b = &#123; value: 2, hello&#125;hello()a.hello()b.hello.apply(a) answer : 用 call 來轉換形式： 123hello() // hello.call() =&gt; windowa.hello() // a.hello.call(a) =&gt; ab.hello.apply(a) // 因為使用了 `apply` =&gt; a question 02 : 123456789101112var x = 10var obj = &#123; x: 20, fn: function() &#123; var test = function() &#123; console.log(this.x) &#125; test() &#125;&#125;obj.fn() answer : 使用 call 轉換形式： 1test() // 轉換成 test.call() -&gt; this 的值為 window，因此 this.x =&gt; 10 在 ES6 的 Arrow Function ( 箭頭函式 ) 中 在 ES6 要注意的是： 變數宣告的地方的 this 就是變數的 this 。 example : 在 function hello 中宣告 arrow function test ， 1234567891011121314const obj = &#123; x: 1, hello: function() &#123; console.log(this) // 這邊的 `this` 就會是 test 的 this const test = () =&gt; &#123; console.log(this.x) &#125; test() &#125;&#125;obj.hello() // 1const hello = obj.hellohello() // undefined 所以我們可以發現， test 這個箭頭函式是在 hello 這個 function 裡面被宣告的，因此 test 這項 function 所印出的 this 就會一樣是 hello 的 this 的值。 因此 obj.hello() 所 log 出來的 this 是 obj ，因此 test 的 this 的值也就是 obj 。 而呼叫 hello() 時， test 的 this 為全域物件，所以是 undefined 。 Reference 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 What’s THIS in JavaScript ?","link":"/2019/09/25/What's THIS in JavaScript/"},{"title":"JavaScript_prototype chain - 1","text":"先從 JavaScript 中的 class 開始 JavaScript 中的繼承機制 有趣的是這其中沒有 “子類別” 與 “父類別” 的概念，也沒有區分 class 與 instance ，皆是由 prototype chain 的模式下實現繼承機制。 JavaScript 設計原理 在早期 ( 西元 1994 年 ) 那時版本的瀏覽器只能單純瀏覽，並沒有辦法與使用者互動，因此當時的 Netscape 希望可用一種網頁腳本語言，讓使用者可以和瀏覽器互動。 Brendan Eich 正是當時研發這項語言的工程師，而那時候的時空背景 object-oriented programming 正流行，Brendan Eich 或許也受到一定程度的影響，因此在 JavaScript 中的數據類型都是 Object 的型態。 JavaScript 需不需要設計繼承機制 ? 如果是一項簡易的語言，到是不需要考慮到繼承機制問題，只不過 JavaScript 中的數據型態都是以 Object 呈現，那就必須有一項機制將這些物件互相聯繫，因此 JavaScript 仍然設計了繼承機制。 但是 Brendan Eich 沒有打算引入 class 的概念，但是他把 new 的命令引入了 JavaScript 中，從原形中生成一個 instance 。 C++ 1ClassName *object = new ClassName(param); Java 1FOO foo = new Foo(); 而上述提到的 C++, Java 在使用 new 時，會使用 class 的 constructor ，不過因為 JavaScript 沒有引入 class 的概念，因此使用 new 時，後面接的不是 class 而是直接接 constructor。 example 現在有一個叫做 Dog 的 constructor，來表示狗的原形： 1234// constructor function Dog(name) &#123; this.name = name;&#125; 我們在使用 new 生成一個狗的 instance： 12var dogA = new Dog(&apos;Doggy&apos;);console.log(dogA.name); // Doggy constructor 基本結構 而剛剛提及的 constructor 又是指什麼事情呢 ? 使用物件導向的第一步，就是生成 instance，而在 JavaScript 中是以 constructor 與 prototype 來進行。生成 instance 時需要一個模板當作我們的藍圖，表示某一類實物的共同特徵，接著再根據這個模板生成。 而 JavaScript 中就是使用 constructor 作為一個模板，每個模板可以生成許多 instance ，每個 instance 都有相同的結構。 constructor基本結構 12345678var Dog = function() &#123; this.height = 100;&#125;// or another wayfunction Dog() &#123; this.height = 100;&#125; 特點：與其他函數的區別 constructor 函數名的第一個字母通常為大寫 函數內使用 this ，代表所要生成的對象 instance 生成 instance 時，必須使用 new 指令來使用 constructor JavaScript 中 new 指令的缺點 使用 constructor 生成 instance 的缺點為無法共享屬性與 methods 例如先在 Dog 的 constructor 中設置一個 instance 的共同屬性 “species”。 1234function Dog(name) &#123; this.name = name this.species = &apos;犬科&apos;;&#125; 再生成兩個 instance 12var dogA = new Dog(&apos;Doggy&apos;);var dogB = new Dog(&apos;Lucky&apos;); 而這兩的 instance 的 species 的屬性是各自獨立的，就算修改其中之一也不會互相影響。 12dogA.species = &apos;貓科&apos;;console.log(dogB.species); // 犬科 因此每一個 instance 都擁有屬於自己的屬性和 methods，但這就無法做到屬性 / 數據共享，使不必要的資源浪費；這時就要分成兩個做法，因為有些屬性例如 age, name 很明顯是每個 instance 會不一樣的，但是又會有某一些屬性或是 methods 會是每個 instance 彼此之間可以共享的。 prototype 屬性的引入 考慮到這部份的確點，Brendan Eich 又決定為 constructor 設置 prototype 的屬性。所有 instance 需要共享這些屬性和 methods 的都放在這裡，不需要共享的則放在 constructor 裡。 當 instance一旦被創造，將自動引用 prototype 對象的屬性和 methods，也可以把 instance 的屬性和方法，分成本地端和引用端兩種型態。 使用 prototype 屬性改寫： 12345678910111213function Dog(name) &#123; this.name = name;&#125;Dog.prototype = &#123; species: &apos;犬科&apos;&#125;var dogA = new Dog(&apos;Doggy&apos;);var dogB = new Dog(&apos;Lucky&apos;);console.log(dogA.species); // 犬科console.log(dogB.species); // 犬科 目前 species 的屬性是放在 prototype 裡面，可以讓兩個 instance 共享，因此只要修改 prototype ，就會同時影響兩個 instance 。 修改 prototype 123Dog.prototype.species = &apos;貓科&apos;;console.log(dogA.species); // 貓科console.log(dogB.species); // 貓科 結論 你有一個 Dog 的函數，就可以把 Dog 當作 constructor ，再利用 1var obj = new Dog() 來 new 一個 Dog 的 instance，並且可以在 Dog.prototype 上寫下想要讓 instance 共同享有的屬性或 methods 。 Reference: 該來理解 JavaScript 的原型鍊了 JavaScript 中的構造函数","link":"/2019/09/10/prototype_1/"},{"title":"call by value or by reference ?","text":"function 參數傳遞方式 先來說明第一種方式： call by value / pass by value 直接舉個例子來看 12345678910function swap(a, b) &#123; var temp = a; a = b; b = temp;&#125;var x = 10;var y = 20;swap(x, y);console.log(x, y); // 10, 20 這是個很有趣的現象，我們上述例子的用意在於希望把 x, y 的值交換，先把 a 指向 temp ( 我們預留的空位 )，把 b 指向給 a ，最後再把 temp 指向給 b。但是其實上述的例子並沒有真的把 x 和 y 的值進行交換，因為我們拿出來交換的東西並不是真正的 x 和 y ，而是 x 和 y 的值的副本。 可以把我們宣告的 a 和 b 想像成兩個新的變數，只是剛好存的值與 x 和 y 一樣，所以就算改變了 a 也不會改變 x ，因為他們本身就是不同的變數 ( 記憶體位置打從一開始就不同 ) 。 call by reference 可以說是和上述第一種方式相反，傳進去的參數則是真的 x 和 y，在 function 裡面宣告的 a 和 b 只是 alias ，如果我們改變了 a 就真的會因此改變 x 。 適用情境 數字 在 JavaScript 中一般情境，例如上面 example 中的 Primitive type ( 原始型別 )，只會使用 call by value ，因為我們無法透過 function 中的引數去改變 function 外的變數。 物件 看起來像是 call by sharing 123456789function add(obj) &#123; obj.number++&#125;var o = &#123; number: 10&#125;add(o)console.log(o.number) // 11 事實其實是… 在看到 Huli 這篇文章所引用的句子時著實也嚇了一跳，「JavaScript 只有 call by value」。 在宣告一個 object 時，在底層實作上，Object 被存取的地方是一個記憶體的位置，概念很像 C 語言的指標，儲存的值是「記憶體位置」。 例如，當我們宣告一個變數時， 123var o = &#123; number: 10&#125; 如果把他具像化的表示的話可能會像這樣： 變數名稱 記憶體位置 儲存的值 0x01 {number: 10} o 0x02 0x01 因此如果從上層來看，o 的值為 {number: 10} ，不過若從底層時做的角度來看，o 的值為記憶體位置的 0x01。 也就是說在 function 裡面的變數是透過「記憶體位置」去操作這些東西，因此 o 和 obj 兩個變數的指標指向了同一個記憶體位置，而底層實作原理就是把 o 的記憶體位置傳給 obj ，所以才能指著同一個位置。 因此我們在前面提到 “適用情境” 中的物件時，這裡提到的 call by sharing ( 傳記憶體位置進去 )，可說是 call by value 的一種，因為原理同樣是傳一個值的備份給它，指是這邊指的 “值” 是記憶體的位置。 結論 定義 call by value 會把傳進去的值先複製一份 (可以是數值、記憶體位置 )，call by reference 在底層實作上也有類似的行為。 在 call by reference 中， x 的記憶體位置和 a 相同， y 的記憶體位置和 b 相同，因此你可以說他們兩兩是相同的。 不過在 call by value 中，就算傳給對方的是指標，也只是代表「指標內所儲存的值」，有就是把記憶體的位置指給對方，或說是指向相同的記憶體位置，但是指標本身還是有不同的記憶體位置 ( 繞口 ~)。 若是想像成，在 call by value 時，等於是新增了一個變數 a ，讓 a 儲存的值和傳進來的參數相同，這樣的想法會比較直覺；而 call by reference 則是把 a 當作 x 的 alias ( 別名 )，但是其實兩者是相同的變數。 從行為上區分 從「行為」本身上區分兩者是比較容易的方法，不同的種類達成的行為不同。 條件 : 在 function 中對引數重新賦值，是否會影響外面的變數 會 -&gt; call by reference 不會 -&gt; call by value Reference 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference? -Is JavaScript a pass-by-reference or pass-by-value language? Evaluation strategy Parameter Passing [筆記] 談談JavaScript中by reference和by value的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」?","link":"/2019/10/06/call by value or reference/"},{"title":"primitive type 與 object 中的賦值差異","text":"賦值差異 在 primitive type 中 變數 a 並不會跟著一起改變 123456789101112 var a = 10 var b = a console.log(a, b) // 10, 10 b = 200 console.log(a, b) // 10, 200 ``` &lt;!-- more --&gt; - 在 object 中 obj 也連同 obj2 一起改變 var obj = { number: 10 } var obj2 = obj console.log(obj, obj2) // {number: 10} {number: 10} obj2.number = 20 console.log(obj, obj2) // {number: 20} {number: 20} 12345### 原理 - 在 primitive type 中 var a = 10 var b = a console.log(a, b) // 10, 10 b = 200 console.log(a, b) // 10, 200 12可以由儲存的記憶體位置來試想，當我們宣告 `var a = 10` 時， a: 10 // 記憶體 a 位置，儲存的值 = 10 12當我們宣告 `var b = a` 時，會把 a 的值複製給 b ，所以 b 的記憶體位置也會存 10 。 a: 10 b: 10 12當我們下指令 `b = 20` 時，此時就將 b 位置的值修改成 20。 a: 10 b: 20 12- 在 object 中 var obj = { number: 10 } var obj2 = obj console.log(obj, obj2) // {number: 10} {number: 10} obj2.number = 20 console.log(obj, obj2) // {number: 20} {number: 20} 12當我們宣告 obj 時，會將 obj 真正的值儲存在某記憶體位置 var obj = { number: 10 } 12可試想儲存在記憶體 0x01 的位置 0x01 { number: 10 } 12此時回頭看 obj 儲存的值其實是這個記憶體位置 obj: 0x01 12因此當我們宣告 `var obj2 = obj` 時，會將 obj 的值，也就是記憶體位置複製給 obj2，所以現在 `obj` 與 `obj2` 會指向同一個記憶體位置。 0x01 { number: 10 } obj: 0x01 obj2: 0x01 12最後當我們執行 `obj2.number = 20` 來改變 obj2 的值的時候，會去找 obj2 的記憶體位置的 number 修改成 20，所以 obj 和 obj2 log 出來的值就會變成相同。 0x01: { number: 20 } obj: 0x01 obj2: 0x01 12若再將例子變換一些， var obj = { number: 10 } var obj2 = obj console.log(obj, obj2) // {number: 10} {number: 10} obj2 = { number: 30 } console.log(obj, obj2) // {number: 10} {number: 30} 12在 `var obj = &#123; number: 10 &#125;` 時，會先建立新的記憶體位置 0x01，再把記憶體位置給予 obj，而 obj2 同上，也會建立另一個新的記憶體位置 0x02，再將記憶體位置給予 obj2。 0x01: { number: 10 } 0x02: { number: 30 } obj: 0x01 obj2: 0x02","link":"/2019/09/13/primitive type 與 object 中的賦值差異/"},{"title":"JavaScript_prototype chain -2","text":"第一回我們了解完 prototype 出現的前因後果，後面我們接續著去探索一下當我們下這些指令的時候， JavaScript 在背後做了哪些事情呢? JavaScript 在背後默默做的事 我們想知道的是，當我們呼叫這程式碼的時候，JavaScript 要如何循著線索找到我們要的答案 ? 1var dogA = new Dog(&apos;Lucky&apos;); 從這幾行中我們還無法看到這個 instance 本身內的 function，但是根據 JavaScript 的機制，如果 dogA 是 Dog 的 instance，就能夠從 Dog.prototype 中尋找屬性或方法。 所以有趣的是，在 DogA 和 Dog.prototype 之間一定有某些關聯或是方式把他們之間串聯在一起，這樣 JavaScript 才能循著找到原型，而這個連接方式也就是 __proto__ ( 兩個底線 )，可參閱 Object.prototype.proto 。 example 1234567891011function Dog(name, age) &#123; this.name = name; this.age = age;&#125;Dog.prototype.log = function () &#123; console.log(this.name + &apos;, age:&apos; + this.age);&#125;var dogA = new Dog(&apos;Lucky&apos;, 5);console.log(dogA.__proto__ === Dog.prototype) // true 在這個例子中， dogA.__proto__ 會指向 Dog.prototype ，所以就算原本的 instance 沒有看到這些 methods ，但是 JavaScript 仍然可以循著這個路徑去找到 Dog.prototype ，以及其中的 methods 。 那有可能會有找不到的情況嗎 ? 那這時候 JavaScript 就會再往下一層 Dog.prototype.__proto__ 去尋找，一直到找到為止 ( 或是找到 null 為止 )，而這項透過 __proto 一直循線找下去的現象稱為 “prototype chain” ( 原型鍊 )，而這就達成了 JavaScript 想要做出類似繼承的功能，可以呼叫自己 parent 的屬性和 methods 。 所以後面我們就來試試如果一直用 __proto 找下去的話會找到什麼呢 ? 12345678910111213141516function Dog(name, age) &#123; this.name = name; this.age = age;&#125;Dog.prototype.log = function () &#123; console.log(this.name + &apos;, age:&apos; + this.age);&#125;var dogA = new Dog(&apos;Lucky&apos;, 5);console.log(dogA.__proto__ === Dog.prototype) // true// 以上為剛剛上方的 example //keep searchingconsole.log(Dog.prototype.__proto__ === Object.prototype) // trueconsole.log(Object.prototype.__proto__) // null, the top of the prototype chain 你的屬性不是你的屬性 ? 既然我們知道 instance 可以有類似繼承 parent 的屬性，那我們又要如何區別某項屬性是 instance 原本就有的，或是他是屬於 prototype 裡面的 ? hasOwnProperty hasOwnProperty 正好提供了這項功能，讓我們直接看範例： 123456789101112function Dog(name, age) &#123; this.name = name; this.age = age;&#125;Dog.prototype.log = function () &#123; console.log(this.name + &apos;, age:&apos; + this.age);&#125;var dogA = new Dog(&apos;Lucky&apos;, 5);console.log(dogA.hasOwnProperty(&apos;log&apos;)); // falseconsole.log(dogA.__proto__.hasOwnProperty(&apos;log&apos;)); // true hasOwnProperty 是不是很方便檢查用呢 ? quiz: 12345678910111213function Dog(name, age) &#123; this.name = name; this.age = age;&#125;Dog.prototype.log = function () &#123; console.log(this.name + &apos;, age:&apos; + this.age);&#125;var dogA = new Dog(&apos;Lucky&apos;, 5);console.log(Dog.__proto__ === Function.prototype); // trueconsole.log(Function.prototype.__proto__ === Object.prototype); //trueconsole.log(Object.prototype.__proto__); //null instanceof 用來判斷 A 是否為 B 的 instance ( 用法： A instanceof B )。 1234567891011121314function Dog(name, age) &#123; this.name = name; this.age = age;&#125;Dog.prototype.log = function () &#123; console.log(this.name + &apos;, age:&apos; + this.age);&#125;var dogA = new Dog(&apos;Lucky&apos;, 5);console.log(dogA instanceof Dog); // trueconsole.log(dogA instanceof Object); // trueconsole.log(dogA instanceof Array); // false constructor 暨上一回有提到 constructor ，每一個 prototype 都有一個叫做 constructor 的屬性 example Dog.prototype.constructor 而這個屬性會指向構造函數，也就是 Dog ( 好像繞口令 ~)。 example 1Dog.prototype 的建構函數也就是 Dog 本身 new 定義 new 這個指令是讓我們在具有 constructor 的 function 中創造一個 instance，當我們下 new 這個指令後，會依序進行： Creates a blank, plain JavaScript object; Links (sets the constructor of) this object to another object; Passes the newly created object from Step 1 as the this context; Returns this if the function doesn’t return its own object. 讓我們先來試看看如何 new operator 123456789function Car(make, model, year) &#123; this.make = make this.model = model this.year = year&#125;var car1 = new Car(&apos;Eagle&apos;, &apos;Talon Tsi&apos;, 1993)console.log(car1.make) // &apos;Eagle&apos; 語法 1new constructor[([arguments])] constructor : A class or function that specifies the type of the object instance arguments : A list of values that the constructor will be called with 因此回應到我們上面的例子中，當我們下了這項指令後，表示： 1var dogA = new Dog(&apos;Lucky&apos;); JavaScript 會幫我們做以下這些事： 創造出一個新的 Object 把這個 Object.proto 指向 Dog.prototype ，形成 prototype chain 把 Object 當作 context ，呼叫 constructor ( 也就是 Dog) 回傳 Object 結論 簡單地說， JavaScript 就是透過 prototype chain 的機制，把各物件的上下關係串聯起來，可以從我們要找的 obj 的 parent ( obj.__proto__ ) 去循線蹤跡，一直到 the top of the prototype chain ( Object.prototype ) ，並一直到 null 結束。","link":"/2019/09/13/prototype_2/"},{"title":"Closure - about closure and scope in JavaScript","text":"Introduction 首先先簡介 Closure 的特性 example 01 : 123456789function test() &#123; var a = 10 function inner() &#123; console.log(a) // 10 &#125; inner()&#125;test() 由這項 function，試著改寫成 =&gt; 不要直接執行 inner ，而是把這整個 function 直接回傳，會變成： 12345678910function test() &#123; var a = 10 function inner() &#123; console.log(a) // 仍為 10 &#125; return inner // 注意：並非 return inner()&#125;var inner = test()inner() 這時因為 return inner 的關係，使變數 a 也存在於 function inner 之中，所以可以將「在 function 之中 return 一個 function」作為 Closure 現象。 一項重要的優點為，可將變數隱藏在 function 內部，不使外部存取到這項變數，也就無法被隨意變更，如以下的例子： example 02 : 1234567var myWallet = 100function deduct(n) &#123; myWallet -= (n &gt; 10 ? 10 : n)&#125;deduct(13) // 90myWallet -= 999 // -909 原本變數在 function 內部中特定條件下執行特定的事情，但仍能被外部存取且修改，若利用 closure 改寫，就能夠避免這項問題。 123456789101112function getWallet() &#123; var myWallet = 100 return &#123; deduct: function(n) &#123; myWallet -= (n &gt; 10 ? 10 : n) &#125; &#125;&#125;var wallet = getWallet()wallet.deduct(13) // 90myWallet -= 999 // Uncaught ReferenceError: my_balance is not defined 上述例子出現錯誤的原因為，因為變數被隱藏在 function 內部，因此外部無法存取到，若需要修改需透過執行 deduct 這項 function，達到隱藏資訊的目的，變數不會被隨意更改。 example 03 : 另一項常見的例子 12345678var arr = []for (var i = 0; i &lt; 4; i++) &#123; arr[i] = function() &#123; console.log(i) // 4 &#125;&#125;arr[0]() 原因為當我們呼叫 arr[0]() 時，程式會去尋找這詞變數 i 為何，但是這時是迴圈已經全部跑完跳出時產生的 i ，因為 function 本身沒有 i 這項變數，因此往作用域的外層尋找時，就是找到這項跑完迴圈的 i ，因此 i 為 4 。 若要解決這項問題，可使用幾種方式： IIFE（Immediately Invoked Function Expression ) 可以將一個 function 包起來並把 i 立即傳給程式執行，因此迴圈每跑一圈就會立刻呼叫一個新的 function ，也就是新產生一個新的作用域。 12345678910var arr = []for (var i = 0; i &lt; 4; i++) &#123; arr[i] = (function(num) &#123; return function() &#123; console.log(num) &#125; &#125;)(i)&#125;arr[0]() let 使用 ES6 語法 12345678var arr = []for (let i = 0; i &lt; 4; i++) &#123; arr[i] = function() &#123; console.log(i) // 4 &#125;&#125;arr[0]() 從 ECMAScript 中探討 scope 10.1.4 Scope Chain and Identifier Resolution Every execution context has associated with it a scope chain. A scope chain is a list of objects that are searched when evaluating an Identifier. When control enters an execution context, a scope chain is created and populated with an initial set of objects, depending on the type of code. 每個 EC 都有屬於自己的 scope chain，當進入 EC 時 scope chain 就會被建立。 10.2 Entering An Execution Context 10.2.3 Function Code The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object. 當進入 EC 時，scope chain 會被初始化為 activation object，並加上 function 的 [[Scope]] 屬性。 1scope chain = AO + [[Scope]] 13.2 Creating Function Objects Given an optional parameter list specified by FormalParameterList, a body specified by FunctionBody, and a scope chain specified by Scope, a Function object is constructed as follows: … 7. Set the [[Scope]] property of F to a new scope chain (10.1.4) that contains the same objects as Scope. 當我們建立 function 時會設定的 [[Scope]] ，裡面內含 scope 。 探討 closure 行程過程及原理 依據上述方式一步一步拆解過程 example 12345678910var v1 = 10function test() &#123; var vTest = 20 function inner() &#123; console.log(v1, vTest) // 10, 20 &#125; return inner&#125;var inner = test()inner() 進入 global EC 進入 global EC，並初始化 VO and scope chain。 12345678globalEC &#123; VO: &#123; v1: undefined, inner: undefined, test: func &#125;, scopeChain: globalEC.VO&#125; 執行主程式 執行 var v1 = 10 以及 var inner = test() 。 12345678910globalEC &#123; VO: &#123; v1: 10, inner: undefined, test: func &#125;, scopeChain: globalEC.VO&#125;test.[[Scope]] = globalEC.scopeChain 進入 test EC 進入 test EC，並初始化 AO and scope chain。 12345678910111213141516171819testEC &#123; AO: &#123; arguments, vTest: undefined, inner: func &#125;, scopeChain: [testEC.AO, globalEC.VO]&#125;globalEC &#123; VO: &#123; v1: 10, inner: undefined, test: func &#125;, scopeChain: globalEC.VO&#125;test.[[Scope]] = globalEC.scopeChain 執行 test 程式 執行 var vTest = 20 與 return inner 。 12345678910111213141516171819testEC &#123; AO: &#123; arguments, vTest: 20, inner: func &#125;, scopeChain: [testEC.AO, globalEC.VO]&#125;globalEC &#123; VO: &#123; v1: 10, inner: func, test: func &#125;, scopeChain: globalEC.VO&#125;inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] 執行 return inner 理論上 return inner 後，function test() 執行完畢後資源會被釋放，但是因為 1inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] inner.[[Scope]] 之中還有需要使用到 testEC.AO 的部分，因此儘管 test 這項 function 執行結束了，但是 testEC.AO 仍需要被存在記憶體中。 進入 inner EC 進入 inner EC，並初始化 AO and scope chain。 1234567891011121314151617181920212223242526innerEC &#123; AO: &#123; arguments &#125;, scopeChain: [innerEC.AO, testEC.AO, globalEC.VO]&#125;testEC &#123; AO: &#123; arguments, vTest: 20, inner: func &#125;, scopeChain: [testEC.AO, globalEC.VO]&#125;globalEC &#123; VO: &#123; v1: 10, inner: func, test: func &#125;, scopeChain: globalEC.VO&#125;inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] 執行 inner 12345678910var v1 = 10function test() &#123; var vTest = 20 function inner() &#123; console.log(v1, vTest) // 10, 20 &#125; return inner&#125;var inner = test()inner() 執行完畢 結論 透過上述的拆解流程可以得知，其實當我們在宣告 function 時，程式背後的 compiler 就已經在幫我們建立 EC 以及初始化 EO/AO 的資訊了，並且把 scope 設定到 [[Scope]] 之中，因此當我們在這段程式碼之中： 123456789function test () &#123; let a = 10 function inner () &#123; console.log(a) &#125; return inner&#125;var inner = test()inner() 使用 return inner 時，就能夠把內部的 function inner 回傳，使後續動作可以藉著執行 inner() 進行。而這樣的形式，我們可以說 inner() 這項 function 是在一個 Closure 之中，因為它也就像是被一項外層的 function 包裹起來。 Reference 所有的函式都是閉包：談 JS 中的作用域與 Closure","link":"/2019/10/01/Closure - about closure and scope in JavaScript/"},{"title":"Hoisting - 從 ECMAScript 下手","text":"讓我們從個小測驗著手吧 quiz 1234567891011121314151617181920var a = 1function test() &#123; console.log(&apos;1.&apos;, a) var a = 7 console.log(&apos;2.&apos;, a) a++ var a inner() console.log(&apos;4.&apos;, a) function inner()&#123; console.log(&apos;3.&apos;, a) a = 30 b = 200 &#125;&#125;test()console.log(&apos;5.&apos;, a)a = 70console.log(&apos;6.&apos;, a)console.log(&apos;7.&apos;, b) answer : 以 hoisting 試想 123456789101112131415161718192021222324var a = 1function test() &#123; var a console.log(&apos;1.&apos;, a) // &apos;1. undefined&apos; a = 7 console.log(&apos;2.&apos;, a) // &apos;2. 7&apos; a++ var a function inner() &#123; console.log(&apos;3.&apos;, a) // &apos;3. 8&apos; a = 30 b = 200 &#125; inner() console.log(&apos;4.&apos;, a) // &apos;4. 30&apos;&#125;test()console.log(&apos;5.&apos;, a) // &apos;5. 1&apos;a = 70console.log(&apos;6.&apos;, a) // &apos;6. 70&apos;console.log(&apos;7.&apos;, b) // &apos;7. 200&apos; ECMAScript Execution Contexts When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. Variable Instantiation Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object. 1234567VO: &#123; a:1&#125;function test() &#123; var a = 1&#125; On entering an execution context, the properties are bound to the variable object in the following order: For function code: for each formal parameter, as defined in the FormalParameterList, create a property of the variable object whose name is the Identifier and whose attributes are determined by the type of code. The values of the parameters are supplied by the caller as arguments to [[Call]]. 12345678910VO: &#123; a: 123, b: undefined&#125;function test(a, b) &#123;&#125;test(123) // 會使參數初始化 For each FunctionDeclaration in the code, in source text order, create a property of the variable object. If the variable object already has a property with this name, replace its value and attributes. 123456789101112VO: &#123; a: 123, b: function&#125;function test(a, b) &#123; function b() &#123; &#125; // 若有同名的，則會被後面的所覆蓋&#125;test(123) For each VariableDeclaration or VariableDeclarationNoIn in the code, create a property of the variable object whose value is undefined. If there is already a property of the variable object with the name of a declared variable, the value of the property and its attributes are not changed. 12345678910111213VO: &#123; a: 123, b: function, c: undefined&#125;function test(a, b) &#123; function b() &#123; &#125; var c = 30&#125;test(123) 了解原理後，回到上述的 quiz quiz 1234567891011121314151617181920var a = 1function test()&#123; console.log(&apos;1.&apos;, a) var a = 7 console.log(&apos;2.&apos;, a) a++ var a inner() console.log(&apos;4.&apos;, a) function inner()&#123; console.log(&apos;3.&apos;, a) a = 30 b = 200 &#125;&#125;test()console.log(&apos;5.&apos;, a)a = 70console.log(&apos;6.&apos;, a)console.log(&apos;7.&apos;, b) answer : 體驗在 JS 引擎中此段程式碼如何被執行 產生 global Execution Context，並初始化 global VO 123global ECglobal VO &#123;&#125; 首先尋找參數，但因為此段並不是 function 所以沒有參數。 接著尋找是否有 function 的宣告 -&gt; 找到 test() 的宣告。 1234global ECglobal VO &#123; test: func&#125; 尋找變數宣告 12345global ECglobal VO &#123; test: func, a: undefined&#125; 開始執行程式 Line 1 : var a = 1; 12345global ECglobal VO &#123; test: func, a: 1&#125; Line 2~15 : function 宣告跳過 Line 16 : 當呼叫一個新的 function test() ，就進入一個新的 execution context 。 產生新的 test Execution Context ，並初始化 test VO : 12345678910test ECtest VO &#123;&#125;global ECglobal VO &#123; test: func, a: 1&#125; 首先尋找參數 -&gt; 無 接著尋找是否有 function 的宣告 -&gt; 找到 inner() 的宣告。 12345678910test ECtest VO &#123; inner: func&#125;global ECglobal VO &#123; test: func, a: 1&#125; 尋找變數宣告 1234567891011test ECtest VO &#123; inner: func, a: undefined&#125;global ECglobal VO &#123; test: func, a: 1&#125; 開始執行程式 Line 3 : console.log('1.', a) // undefined Line 4 : var a = 7 1234567891011test ECtest VO &#123; inner: func, a: 7&#125;global ECglobal VO &#123; test: func, a: 1&#125; Line 5 : console.log('2.', a) // 7 Line 6 : a++ 1234567891011test ECtest VO &#123; inner: func, a: 8&#125;global ECglobal VO &#123; test: func, a: 1&#125; Line 8 : inner() 產生新的 inner Execution Context ，並初始化 inner VO : 12345678910111213141516inner ECinner VO &#123;&#125;test ECtest VO &#123; inner: func, a: 8&#125;global ECglobal VO &#123; test: func, a: 1&#125; function inner() 中沒有傳入任何參數，裡面也沒有 function 以及變數。 12345678910111213141516inner ECinner VO &#123;&#125;test ECtest VO &#123; inner: func, a: 8&#125;global ECglobal VO &#123; test: func, a: 1&#125; 開始執行程式 * Line 11 : console.log('3.', a) // 8 12345678910111213141516inner ECinner VO &#123;&#125;test ECtest VO &#123; inner: func, a: 8&#125;global ECglobal VO &#123; test: func, a: 1&#125; 因為 inner VO 裡面是空的，因此往上找至 test VO -&gt; a: 8 。 Line 12 : a = 30 12345678910111213141516inner ECinner VO &#123;&#125;test ECtest VO &#123; inner: func, a: 30&#125;global ECglobal VO &#123; test: func, a: 1&#125; Line 13 : b = 200 因為 inner VO 裡面沒有 b 的資訊，因此往上找至 test VO ，發現裡面也沒有 b 的資訊，繼續往上至 global VO 找，仍沒有 b 的資訊，最後在 global VO 建立 b 的資訊 ( 讓 b 變成全域變數 )。 1234567891011121314151617inner ECinner VO &#123;&#125;test ECtest VO &#123; inner: func, a: 30&#125;global ECglobal VO &#123; test: func, a: 1, b: 200&#125; 執行完 inner()，將 inner EC pop 出去。 123456789101112test ECtest VO &#123; inner: func, a: 30&#125;global ECglobal VO &#123; test: func, a: 1, b: 200&#125; 回到 function test() {} 內部 Line 9 : console.log('4.', a) // 30 執行完 test()，將 test EC pop 出去。 123456global ECglobal VO &#123; test: func, a: 1, b: 200&#125; 回到 global EC Line 17 : console.log('5.', a) // 1 Line 18 : a = 70 123456global ECglobal VO &#123; test: func, a: 70, b: 200&#125; Line 19 : console.log('6.', a) // 70 Line 20 : console.log('7.', a) // 200 主程式執行完畢 Reference ECMA-262 - Ecma International 我知道你懂 hoisting，可是你了解到多深？","link":"/2019/09/23/Hoisting - 從 ECMAScript 下手/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"Documentation","slug":"Documentation","link":"/categories/Documentation/"}]}