{"pages":[{"title":"Minos - A Hexo theme","text":"","link":"/about/index.html"},{"title":"about","text":"","link":"/about/index-2.html"},{"title":"about","text":"","link":"/about/index-1.html"}],"posts":[{"title":"","text":"let and const (ES6)const全名為 constant ( 常數 )，相對於 var ( 變數 )，需要一開始即指定一初始值給 const，且不能在後續的步驟修改 const 的值。 需先指定一初始值，否則會出現錯誤 Missing initializer in const declaration 12const bb = 20 // Error: `Missing initializer in const declaration` 不能在後續修改 const 的值，否則出現錯誤 Assignment to constant variable 。 12const b = 10b = 20 // Error: `Assignment to constant variable` let 以及 var 則無此限制 應用 example 01 : 12345const obj = &#123; number: 1&#125;obj.number = 2 此時當執行 obj.number 時，程式會去修改其中 obj 所儲存的記憶體位置中的 number 的值，而不會去修改到記憶體位置，因此不會出錯，可想像成 12345678910110x01: &#123; number: 2&#125; // 其中的 number 的值修改成 2obj:0x01const obj = &#123; number: 1&#125;obj.number = 2 example 02 : 1234567const obj = &#123; number: 1&#125;obj = &#123; number: 2&#125; 這時已產生一個新的記憶體位置來放 number: 2 的值，之後再將這新的記憶體位置只給 obj 但此時已修改到 const obj 的值了，因此會發生錯誤。 12345678910111213141516170x01: &#123; number: 2&#125;0x02: &#123; number: 2&#125;obj:0x02 // obj 的值 ( 也就是儲存的記憶體位置 ) 被修改了const obj = &#123; number: 1&#125;obj = &#123; number: 2&#125; // Error: `Assignment to constant variable`","link":"/2019/10/09/Technology/Introduction - let and const (ES6)/"},{"title":"","text":"let and const (ES6) 的生存範圍前言：在 ES6 之前，scope 作用域的最基本單位為 function，只要有 function 就會產生新的作用域；但若在 ES6 之後，最基本單位為 block 。 scope var 作用域範圍為 function 之內都可使用 123456789function() &#123; var a = 60 if (a === 60) &#123; var b = 10 &#125; console.log(b) // 10&#125;test() let or const example 01 : 123456789function() &#123; var a = 60 if (a === 60) &#123; let b = 10 &#125; console.log(b) // b is not defined&#125;test() 因為在 ES6 之後，使用 let or const ，其作用域會存在於 block 中，因此在這個狀況下跳脫出 if 的範圍外後，就無法存取到 b 。 example 02 : 使用 var 宣告的情況下： 12345678function test() &#123; for (var i=0; i&lt;10; i++) &#123; console.log(&apos;i:&apos;, i) &#125; console.log(&apos;final value:&apos;, i)&#125;test() answer: 12345678910i: 1i: 2i: 3i: 4i: 5i: 6i: 7i: 8i: 9final value: 10 // 可存取到 function 中的所有變數 使用 let or const 宣告的情況下： 12345678function test() &#123; for (let i=0; i&lt;10; i++) &#123; console.log(&apos;i:&apos;, i) &#125; console.log(&apos;final value:&apos;, i)&#125;test() answer: 12345678910i: 1i: 2i: 3i: 4i: 5i: 6i: 7i: 8i: 9i is not defined","link":"/2019/10/09/Technology/Scope - let and const (ES6)/"},{"title":"","text":"WebpackWebpack 超入門安裝 Global Installation 1npm install webpack --save-dev 建立專案資料夾 ```1* ```cd &lt;folder name&gt; 建立 npm 專案 init```123456789101112 1. `package name` : 專案名稱 2. `version` : 版本號 3. `description` : 專案敘述 4. `entry point` : 專案執行進入點 ( 預設值為 index.js) 5. `test ccommand` : 專案測試指令 6. `git repository` : 專案原始碼的版本控管位置 7. `keywords` : 專案關鍵字 8. `author` : 專案作者 9. `license` : 專案版權- 建置文件 * src/index.js import bar from ‘./bar’; bar();1* src/bar.js export default function bar() { //}12- 設定 webpack.config.js 檔 const path = require(‘path’); // 引用 path 模組 module.exports = {entry: ‘./src/index.js’, // webpack 打包對象output: { path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos;}};1- 在 html / or 文件中引入 ... ... 1- 執行 npx webpack –config webpack.config.js Reference webpack Installation 使用 Webpack 綁定應用程式 webpack 模組綁定程式","link":"/2019/10/09/Technology/Webpack/"},{"title":"","text":"Scope 作用域 (ES6 以前)變數的生存範圍 Scope 的最基本單位 - function 在 JavaScript 中，ES6 之前 Scope 的基本單位為 function，在 function 才能產生一個新的作用域。 1234567function test() &#123; var a = 10 console.log(a)&#125;test() // 10console.log(a) // ReferenceError: a is not defined 因此這個例子中，function test() 會產生一個 test scope，而 a 就會宣告在這個 test 的 scope 裡面，所以 a 只有在此 function 裡面才能被看到，在 function 之外就無法看到此變數，出現錯誤 ReferenceError: a is not defined 。 global variable 1234567var a = 20 // global variablefunction test() &#123; console.log(a)&#125;test() // 20console.log(a) // 20 優先順序 程式會優先尋找 function 中的變數，若無再往上至 global variable 尋找。 12345678var a = 20 // global variablefunction test() &#123; var a = 10 console.log(a)&#125;test() // 10console.log(a) // 20 若我們將變數範圍印出，可更清楚 scope 範圍 1234567891011121314var a = &apos;global&apos;function test() &#123; var a = &apos;test scope a&apos; var b = &apos;test scope b&apos; console.log(a, b) // test scope a, test scope b function inner() &#123; var b = &apos;inner scope b&apos; console.log(a, b) // test scope a, inner scope b &#125; inner() &#125;test() console.log(a) // global scope chain 作用域鍊由上可得結論，作用域的優先尋找順序為 inner scope -&gt; test scope -&gt; global scope 。","link":"/2019/10/09/Technology/Scope - var (ES6 以前)/"},{"title":"","text":"primitive type 與 object 中的賦值差異賦值差異 在 primitive type 中 變數 a 並不會跟著一起改變 1234567891011 var a = 10 var b = a console.log(a, b) // 10, 10 b = 200 console.log(a, b) // 10, 200 ``` - 在 object 中 obj 也連同 obj2 一起改變 var obj = { number: 10 } var obj2 = obj console.log(obj, obj2) // {number: 10} {number: 10} obj2.number = 20 console.log(obj, obj2) // {number: 20} {number: 20} 123### 原理 - 在 primitive type 中 var a = 10 var b = a console.log(a, b) // 10, 10 b = 200 console.log(a, b) // 10, 200 12可以由儲存的記憶體位置來試想，當我們宣告 ```var a = 10``` 時， a: 10 // 記憶體 a 位置，儲存的值 = 10 1當我們宣告 ```var b = a``` 時，會把 a 的值複製給 b ，所以 b 的記憶體位置也會存 10 。 a: 10 b: 10 1當我們下指令 ```b = 20``` 時，此時就將 b 位置的值修改成 20。 a: 10 b: 20 12- 在 object 中 var obj = { number: 10 } var obj2 = obj console.log(obj, obj2) // {number: 10} {number: 10} obj2.number = 20 console.log(obj, obj2) // {number: 20} {number: 20} 12當我們宣告 obj 時，會將 obj 真正的值儲存在某記憶體位置 var obj = { number: 10 } 1可試想儲存在記憶體 0x01 的位置 0x01 { number: 10 } 1此時回頭看 obj 儲存的值其實是這個記憶體位置 obj: 0x01 1因此當我們宣告 ```var obj2 = obj``` 時，會將 obj 的值，也就是記憶體位置複製給 obj2，所以現在 ```obj``` 與 ```obj2``` 會指向同一個記憶體位置。 0x01 { number: 10 } obj: 0x01 obj2: 0x01 1最後當我們執行 ```obj2.number = 20``` 來改變 obj2 的值的時候，會去找 obj2 的記憶體位置的 number 修改成 20，所以 obj 和 obj2 log 出來的值就會變成相同。 0x01: { number: 20 } obj: 0x01 obj2: 0x01 1若再將例子變換一些， var obj = { number: 10 } var obj2 = obj console.log(obj, obj2) // {number: 10} {number: 10} obj2 = { number: 30 } console.log(obj, obj2) // {number: 10} {number: 30} 1在 ```var obj = &#123; number: 10 &#125;``` 時，會先建立新的記憶體位置 0x01，再把記憶體位置給予 obj，而 obj2 同上，也會建立另一個新的記憶體位置 0x02，再將記憶體位置給予 obj2。 0x01: { number: 10 } 0x02: { number: 30 } obj: 0x01 obj2: 0x02 ```","link":"/2019/10/09/Technology/primitive type 與 object 中的賦值差異/"},{"title":"","text":"JavaScript_prototype chain #1Reference: 該來理解 JavaScript 的原型鍊了先從 JavaScript 中的 class 開始JavaScript 中的繼承機制有趣的是這其中沒有 “子類別” 與 “父類別” 的概念，也沒有區分 與 ```instance``` ，皆是由 ```prototype chain``` 的模式下實現繼承機制。1234567891011### JavaScript 設計原理在早期 ( 西元 1994 年 ) 那時版本的瀏覽器只能單純瀏覽，並沒有辦法與使用者互動，因此當時的 Netscape 希望可用一種網頁腳本語言，讓使用者可以和瀏覽器互動。Brendan Eich 正是當時研發這項語言的工程師，而那時候的時空背景 object-oriented programming 正流行，Brendan Eich 或許也受到一定程度的影響，因此在 JavaScript 中的數據類型都是 Object 的型態。### JavaScript 需不需要設計繼承機制 ?如果是一項簡易的語言，到是不需要考慮到繼承機制問題，只不過 JavaScript 中的數據型態都是以 Object 呈現，那就必須有一項機制將這些物件互相聯繫，因此 JavaScript 仍然設計了繼承機制。但是 Brendan Eich 沒有打算引入 ```class``` 的概念，但是他把 ```new``` 的命令引入了 JavaScript 中，從原形中生成一個 instance 。 - C++ ClassName *object = new ClassName(param);12- Java FOO foo = new Foo(); 12345而上述提到的 C++, Java 在使用 ```new``` 時，會使用 ```class``` 的 ```constructor``` ，不過因為 JavaScript 沒有引入 ```class``` 的概念，因此使用 ```new``` 時，後面接的不是 ```class``` 而是直接接 ```constructor```。 - example 現在有一個叫做 Dog 的 constructor，來表示狗的原形： // constructorfunction Dog(name) { this.name = name;} 1我們在使用 ```new``` 生成一個狗的 instance： var dogA = new Dog(‘Doggy’);console.log(dogA.name); // Doggy123456789101112#### Reference [JavaScript 中的构造函数](https://juejin.im/entry/584a1c98ac502e006c5d63b8)### constructor 基本結構而剛剛提及的 constructor 又是指什麼事情呢 ? 使用物件導向的第一步，就是生成 instance，而在 JavaScript 中是以 constructor 與 prototype 來進行。生成 instance 時需要一個模板當作我們的藍圖，表示某一類實物的共同特徵，接著再根據這個模板生成。而 JavaScript 中就是使用 constructor 作為一個模板，每個模板可以生成許多 instance ，每個 instance 都有相同的結構。 - constructor基本結構 var Dog = function() { this.height = 100;}// or another way function Dog() { this.height = 100;}12345- 特點：與其他函數的區別 * constructor 函數名的第一個字母通常為大寫 * 函數內使用 ```this``` ，代表所要生成的對象 instance * 生成 instance 時，必須使用 ```new``` 指令來使用 ```constructor JavaScript 中 new 指令的缺點使用 生成 instance 的缺點為無法共享屬性與 methods12- 例如先在 Dog 的 ```constructor``` 中設置一個 instance 的共同屬性 &quot;species&quot;。 function Dog(name) { this.name = name this.species = ‘犬科’;}1- 再生成兩個 instance var dogA = new Dog(‘Doggy’); var dogB = new Dog(‘Lucky’); 1- 而這兩的 instance 的 species 的屬性是各自獨立的，就算修改其中之一也不會互相影響。 dogA.species = ‘貓科’; console.log(dogB.species); // 犬科 123456789 因此每一個 instance 都擁有屬於自己的屬性和 methods，但這就無法做到屬性 / 數據共享，使不必要的資源浪費；這時就要分成兩個做法，因為有些屬性例如 age, name 很明顯是每個 instance 會不一樣的，但是又會有某一些屬性或是 methods 會是每個 instance 彼此之間可以共享的。 ### prototype 屬性的引入考慮到這部份的確點，Brendan Eich 又決定為 ```constructor``` 設置 ```prototype``` 的屬性。所有 instance 需要共享這些屬性和 methods 的都放在這裡，不需要共享的則放在 constructor 裡。當 instance一旦被創造，將自動引用 ```prototype``` 對象的屬性和 methods，也可以把 instance 的屬性和方法，分成本地端和引用端兩種型態。 - 使用 ```prototype``` 屬性改寫： function Dog(name) { this.name = name;} Dog.prototype = { species: ‘犬科’} var dogA = new Dog(‘Doggy’);var dogB = new Dog(‘Lucky’); console.log(dogA.species); // 犬科console.log(dogB.species); // 犬科123目前 species 的屬性是放在 ```prototype``` 裡面，可以讓兩個 instance 共享，因此只要修改 ```prototype``` ，就會同時影響兩個 instance 。 - 修改 ```prototype 123 Dog.prototype.species = &apos;貓科&apos;;console.log(dogA.species); // 貓科console.log(dogB.species); // 貓科 結論你有一個 的函數，就可以把 ```Dog``` 當作 ```constructor``` ，再利用12```var obj = new Dog() 來 new 一個 Dog 的 instance，並且可以在 Dog.prototype 上寫下想要讓 instance 共同享有的屬性或 methods 。","link":"/2019/10/09/Technology/prototype_1/"},{"title":"","text":"call by value or by reference ?function 參數傳遞方式先來說明第一種方式： call by value / pass by value 直接舉個例子來看 12345678910function swap(a, b) &#123; var temp = a; a = b; b = temp;&#125;var x = 10;var y = 20;swap(x, y);console.log(x, y); // 10, 20 這是個很有趣的現象，我們上述例子的用意在於希望把 x, y 的值交換，先把 a 指向 temp ( 我們預留的空位 )，把 b 指向給 a ，最後再把 temp 指向給 b。但是其實上述的例子並沒有真的把 和 ```y``` 的值進行交換，因為我們拿出來交換的東西並不是真正的 ```x``` 和 ```y``` ，而是 ```x``` 和 ```y``` 的值的副本。123456789101112131415 可以把我們宣告的 ```a``` 和 ```b``` 想像成兩個新的變數，只是剛好存的值與 ```x``` 和 ```y``` 一樣，所以就算改變了 ```a``` 也不會改變 ```x``` ，因為他們本身就是不同的變數 ( 記憶體位置打從一開始就不同 ) 。 第二種方式： - call by reference 可以說是和上述第一種方式相反，傳進去的參數則是真的 ```x``` 和 ```y```，在 function 裡面宣告的 ```a``` 和 ```b``` 只是 alias ，如果我們改變了 ```a``` 就真的會因此改變 ```x``` 。---### 適用情境 - 數字 在 JavaScript 中一般情境，例如上面 example 中的 Primitive type ( 原始型別 )，只會使用 call by value ，因為我們無法透過 function 中的引數去改變 function 外的變數。 - 物件 * 看起來像是 call by sharing function add(obj) { obj.number++ } var o = { number: 10 } add(o) console.log(o.number) // 11 123456### 事實其實是....在看到 Huli 這篇文章所引用的句子時著實也嚇了一跳，「JavaScript 只有 call by value」。在宣告一個 object 時，在底層實作上，Object 被存取的地方是一個記憶體的位置，概念很像 C 語言的指標，儲存的值是「記憶體位置」。例如，當我們宣告一個變數時， var o = { number: 10 } 如果把他具像化的表示的話可能會像這樣：| 變數名稱 | 記憶體位置 | 儲存的值 || ——- |:———:| ——–:|| | 0x01 | {number: 10}|| o | 0x02 | 0x01 | 因此如果從上層來看，o 的值為 {number: 10} ，不過若從底層時做的角度來看，o 的值為記憶體位置的 0x01。 也就是說在 function 裡面的變數是透過「記憶體位置」去操作這些東西，因此 o 和 obj 兩個變數的指標指向了同一個記憶體位置，而底層實作原理就是把 o 的記憶體位置傳給 obj ，所以才能指著同一個位置。 因此我們在前面提到 “適用情境” 中的物件時，這裡提到的 call by sharing ( 傳記憶體位置進去 )，可說是 call by value 的一種，因為原理同樣是傳一個值的備份給它，指是這邊指的 “值” 是記憶體的位置。 結論定義 call by value 會把傳進去的值先複製一份 (可以是數值、記憶體位置 )，call by reference 在底層實作上也有類似的行為。 在 call by reference 中， x 的記憶體位置和 a 相同， y 的記憶體位置和 b 相同，因此你可以說他們兩兩是相同的。 不過在 call by value 中，就算傳給對方的是指標，也只是代表「指標內所儲存的值」，有就是把記憶體的位置指給對方，或說是指向相同的記憶體位置，但是指標本身還是有不同的記憶體位置 ( 繞口 ~)。 若是想像成，在 call by value 時，等於是新增了一個變數 a ，讓 a 儲存的值和傳進來的參數相同，這樣的想法會比較直覺；而 call by reference 則是把 a 當作 x 的 alias ( 別名 )，但是其實兩者是相同的變數。 從行為上區分從「行為」本身上區分兩者是比較容易的方法，不同的種類達成的行為不同。 條件 : 在 function 中對引數重新賦值，是否會影響外面的變數 會 -&gt; call by reference 不會 -&gt; call by value Reference 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference? Is JavaScript a pass-by-reference or pass-by-value language? Evaluation strategy Parameter Passing [筆記] 談談JavaScript中by reference和by value的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」?","link":"/2019/10/09/Technology/call by value or reference/"},{"title":"","text":"JavaScript_prototype chain #2Reference: 該來理解 JavaScript 的原型鍊了第一回我們了解完 prototype 出現的前因後果，後面我們接續著去探索一下當我們下這些指令的時候， JavaScript 在背後做了哪些事情呢? JavaScript 在背後默默做的事 原理我們想知道的是，當我們呼叫這程式碼的時候，JavaScript 要如何循著線索找到我們要的答案 ?1var dogA = new Dog(&apos;Lucky&apos;); 從這幾行中我們還無法看到這個 instance 本身內的 function，但是根據 JavaScript 的機制，如果 dogA 是 Dog 的 instance，就能夠從 中尋找屬性或方法。1234所以有趣的是，在 DogA 和 ```Dog.prototype``` 之間一定有某些關聯或是方式把他們之間串聯在一起，這樣 JavaScript 才能循著找到原型，而這個連接方式也就是 ```__proto__``` ( 兩個底線 )，可參閱 [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) 。 - example function Dog(name, age) { this.name = name; this.age = age;} Dog.prototype.log = function () { console.log(this.name + ‘, age:’ + this.age);} var dogA = new Dog(‘Lucky’, 5);console.log(dogA.proto === Dog.prototype) // true123456在這個例子中， ```dogA.__proto__``` 會指向 ```Dog.prototype``` ，所以就算原本的 instance 沒有看到這些 methods ，但是 JavaScript 仍然可以循著這個路徑去找到 ```Dog.prototype``` ，以及其中的 methods 。那有可能會有找不到的情況嗎 ? 那這時候 JavaScript 就會再往下一層 ```Dog.prototype.__proto__``` 去尋找，一直到找到為止 ( 或是找到 null 為止 )，， 而這項透過 ```__proto``` 一直循線找下去的現象稱為 &quot;prototype chain&quot; ( 原型鍊 )，而這就達成了 JavaScript 想要做出類似繼承的功能，可以呼叫自己 parent 的屬性和 methods 。所以後面我們就來試試如果一直用 ```__proto``` 找下去的話會找到什麼呢 ? function Dog(name, age) { this.name = name; this.age = age;} Dog.prototype.log = function () { console.log(this.name + ‘, age:’ + this.age);} var dogA = new Dog(‘Lucky’, 5);console.log(dogA.proto === Dog.prototype) // true// 以上為剛剛上方的 example //keep searchingconsole.log(Dog.prototype.proto === Object.prototype) // trueconsole.log(Object.prototype.proto) // null, the top of the prototype chain123456### 你的屬性不是你的屬性 ? 既然我們知道 instance 可以有類似繼承 parent 的屬性，那我們又要如何區別某項屬性是 instance 原本就有的，或是他是屬於 ```prototype``` 裡面的 ?#### hasOwnProperty```hasOwnProperty``` 正好提供了這項功能，讓我們直接看範例： function Dog(name, age) { this.name = name; this.age = age;} Dog.prototype.log = function () { console.log(this.name + ‘, age:’ + this.age);} var dogA = new Dog(‘Lucky’, 5);console.log(dogA.hasOwnProperty(‘log’)); // falseconsole.log(dogA.proto.hasOwnProperty(‘log’)); // true123```hasOwnProperty``` 是不是很方便檢查用呢 ? - quiz: function Dog(name, age) { this.name = name; this.age = age; } Dog.prototype.log = function () { console.log(this.name + &apos;, age:&apos; + this.age); } var dogA = new Dog(&apos;Lucky&apos;, 5); console.log(Dog.__proto__ === Function.prototype); // true console.log(Function.prototype.__proto__ === Object.prototype); //true console.log(Object.prototype.__proto__); //null 123---### instanceof用來判斷 A 是否為 B 的 instance ( 用法： ``` A instanceof B ``` )。function Dog(name, age) { this.name = name; this.age = age;} Dog.prototype.log = function () { console.log(this.name + ‘, age:’ + this.age);} var dogA = new Dog(‘Lucky’, 5); console.log(dogA instanceof Dog); // trueconsole.log(dogA instanceof Object); // trueconsole.log(dogA instanceof Array); // false12345---### constructor暨上一回有提到 ```constructor``` ，每一個 prototype 都有一個叫做 ```constructor``` 的屬性 - example ```Dog.prototype.constructor 而這個屬性會指向構造函數，也就是 ( 好像繞口令 ~)。1- example Dog.prototype 的建構函數也就是 Dog 本身 12345678910---### new #### 定義```new``` 這個指令是讓我們在具有 constructor 的 function 中創造一個 instance，當我們下 ```new``` 這個指令後，會依序進行： 1. Creates a blank, plain JavaScript object; 2. Links (sets the constructor of) this object to another object; 3. Passes the newly created object from Step 1 as the this context; 4. Returns this if the function doesn&apos;t return its own object. 讓我們先來試看看如何 ```new operator 123456789function Car(make, model, year) &#123; this.make = make this.model = model this.year = year&#125;var car1 = new Car(&apos;Eagle&apos;, &apos;Talon Tsi&apos;, 1993)console.log(car1.make) // &apos;Eagle&apos; 語法1new constructor[([arguments])] constructor : A class or function that specifies the type of the object instance arguments : A list of values that the constructor will be called with 因此回應到我們上面的例子中，當我們下了這項指令後，表示：1var dogA = new Dog(&apos;Lucky&apos;); JavaScript 會幫我們做以下這些事： 創造出一個新的 Object 把這個 Object.proto 指向 Dog.prototype ，形成 prototype chain 把 Object 當作 context ，呼叫 constructor ( 也就是 Dog) 回傳 Object 結論簡單地說， JavaScript 就是透過 prototype chain 的機制，把各物件的上下關係串聯起來，可以從我們要找的 obj 的 parent ( obj.__proto__ ) 去循線蹤跡，一直到 the top of the prototype chain ( Object.prototype ) ，並一直到 null 結束。","link":"/2019/10/09/Technology/prototype_2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/08/Technology/hello-world/"}],"tags":[],"categories":[]}